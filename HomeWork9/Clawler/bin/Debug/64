<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-crossorigin" />
    <meta name="description" content="i2c（或IIC）协议使用两根线进行通信（不包括电源正负极），它们分别为： 1、SDA：数据线，IIC 协议允许在单根数据线上进行双向通信——这条线既可以发送数据，也可以接收数据。 2、SCL：时钟线" />
    <meta property="og:description" content="i2c（或IIC）协议使用两根线进行通信（不包括电源正负极），它们分别为： 1、SDA：数据线，IIC 协议允许在单根数据线上进行双向通信——这条线既可以发送数据，也可以接收数据。 2、SCL：时钟线" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>【.NET 与树莓派】i2c（IIC）通信 - 东邪独孤 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=zS6-e1bxywlu3kpHvpr1J6MySwya3ztFtEnS7RYQ0Fk" />
    <link id="MainCss" rel="stylesheet" href="/skins/moonlightink/bundle-moonlightink.min.css?v=iVE30sZ6vb6blzqPWbGs2kM432fxmh8k3P9XllAp48s" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/moonlightink/bundle-moonlightink-mobile.min.css?v=axcwoS9UbqWFSKj9O2YcPP0sVreDAEIZDpcqOVKt8M4" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/tcjiaan/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/tcjiaan/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/tcjiaan/wlwmanifest.xml" />
    <script>
        var currentBlogId = 113198;
        var currentBlogApp = 'tcjiaan';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'MoonlightInk';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-01-31 05:48';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=2Mic1VLeHXarpdzASbXqFMIMVLEBiWXNO5yiTHUcmhw"></script>
    
    
    
</head>
<body class="has-navbar">
    <a name="top"></a>
        <div id="bannerbar" class="bannerbar-mobile formobile">
            <a href="https://developer.aliyun.com/learning/trainingcamp/realtime/1?utm_content=g_1000268661" target="_blank" onclick="ga('send', 'event', 'Link', 'click', 'aliyun-realtime-blog-bannerbar-mobile')">
                <img src="https://img2020.cnblogs.com/blog/35695/202105/35695-20210509221214222-438425324.png" alt="" />
            </a>
        </div>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/tcjiaan/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/tcjiaan/">老周</a>
</h1>
<h2>成于天性，行于自然。</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/tcjiaan/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E4%B8%9C%E9%82%AA%E7%8B%AC%E5%AD%A4">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/tcjiaan/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/tcjiaan/p/14348436.html">
    <span>【.NET 与树莓派】i2c（IIC）通信</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>i2c（或IIC）协议使用两根线进行通信（不包括电源正负极），它们分别为：</p>
<p>1、SDA：数据线，IIC 协议允许在单根数据线上进行双向通信——这条线既可以发送数据，也可以接收数据。</p>
<p>2、SCL：时钟线，注意了，这个时钟线跟我们平时所说的时钟没什么关系，不要以为这根线是用来接手表的。其实，这里所说的“时钟”，更像是我们看音乐会的时候，站在前面最中央处的那个指挥者，或者说节拍器。它的作用就是协调硬件之间的传输节奏，做到步伐一致，不然数据就会乱了。比如，IIC通信里面，当时钟线的电平拉高后，数据线的内容就不能改变，也就是说，SCL高电平时，不能写数据，但可以读。当SCL下降为低电平后，才能向数据线（SDA）写入数据。</p>
<p>IIC 通信以 Start 信号开始，以 Stop 信号结束。</p>
<p><span style="color: rgba(0, 0, 128, 1)">传送开始信号的方法：拉高SCL和SDA的电平，在SCL处于高电平的情况下把SDA的电平拉低。</span></p>
<p><span style="color: rgba(0, 0, 128, 1)">传送结束信号的方法：拉高SCL的电平，在SCL处于高电平的情况下，把SDA的电平拉高。</span></p>
<p>这其中，你会发现规律：无论是开始信号还是结束信号，<span style="text-decoration: underline"><strong>SCL 都处于高电平</strong></span>，前文提过，时钟线拉高就是固定数据线上的内容，显然，在开始和结束信号中，是不能传数据的。在SDA上，开始信号和结束信号刚好相反，Start 时电平拉低，Stop 时电平拉高。下面这张图是从 IIC 的协议手册上盗来的。</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210130101729585-750147910.png" width="600" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>写入数据时，主机先把时钟线SCL拉低，然后写入一个二进制位（高电平为1，低电平为0），然后把SCL拉高，此时从机读取这个二进制位。接着第二个二进制位也是这样，主机拉低SCL，写SDA，再拉高SCL，从机读……当发送完 8 个二进制（一个字节）后，在第九个时钟周期，主机把SDA拉高（有时候需要切换为输入模式），再拉高SCL，等待从机写应答；如果主机从SDA上读到低电平，表示从机有应答（你的红包我收到了），要是读到高电平，表示无应答（你啥时候发的红包？我都没看到）。</p>
<p>从机向主机发送数据的过程也一样，SCL仍然由主机操控，SCL拉低后向SDA写数据，SCL拉高后就不能写了，此时主机读SDA上的数据。通常主机在接收完最后一个字节后可以不应答（让SCL和SDA同时高电平），或直接发送 Stop 信号终止通信（毕竟主机权力大，生死予夺都是主机说了算）。</p>
<p>上面的东东看得好像很乱，刚接触时就是这样的，见多了就熟悉了。可以大概地总结一下：</p>
<p>1、SCL低电平时，发送方写SDA；</p>
<p>2、SCL高电平锁定SDA，发送方不能写，接收方读；</p>
<p>3、应答信号：SCL高 + SDA低---&gt; 有应答；SCL高 + SDA高---&gt; 无应答。</p>
<p>&nbsp;</p>
<p>其实，我们实际开发中，不了解协议时序也没关系，我们也很少手动去模拟 IIC 通信过程。尤其是像树莓派这种带操作系统的开发板，更不应该手动去模拟，而是直接用现成的库（或者API）。不管你什么语言，你都是先向系统发送指令，然后系统去控制硬件，效率上都无法保证。而且，IIC 协议都是标准化的协议，你每次写程序都去手动模拟通信，浪费时间，意义也不大。这好比我们在 Socket 编程时一样，你不可能总去自己写个协议再来通信吧。一般都会直接用 TCP 或 UDP 协议。</p>
<p>所以，对于IIC协议也是如此，我们了解一下就行了。老周上面在介绍时也是简略化的，所以你可能看得有点晕，若想深入理解，可以看数据手册。毕竟老周不可能把手册上的内容复制过来的，那就是抄袭了。</p>
<p>好，继续。</p>
<p>IIC 总线可以挂多个从机，从机不会主动发起通信，都是由主机发起通信的。因此，主机必须知道要跟哪个从机通信，故挂到总线上的从机必须拥有唯一的地址——这就是所谓的器件地址。就像一个内网中的 N 台电脑一样，每台电脑都要给它分配唯一的 IP 地址，这样你才能知道你正在跟谁说话。哪怕是 UDP 广播，也是有广播地址，192.168.1.255。</p>
<p>IIC 器件地址，7位地址最常见，当然也有 10 位的（老周买的各种模块中都没见到），这个【位】是二进制位，常用的 7 位就是7个二进制位。7 位地址格式如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210130110016897-1474936478.png" alt="" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;低位在右边，从右到左，我们看到第 1 位是 R/W，表示读写位，就是用来告诉从机，我要读数据还是写数据。“W”头顶上有个横线，表示低电平，即 0 表示写，1 表示读。从第二位到第八位就是从机的地址了。所以，现在你知道为啥地址是7位的原因了吧，就是要留一位来确定读还是写。</p>
<p>假如某品牌的自动铲屎机使用 IIC 通信协议，标签上告诉你它的从机地址是 0x47，先把它弄成二进制。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(128, 0, 128, 1)">0100</span> <span style="color: rgba(128, 0, 128, 1)">0111</span></pre>
</div>
<p>第八位是0，所以有效的值是第一位到第七位，属7位地址。当主机要向铲屎机发起通信时，需要把地址左移一位，变成：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(128, 0, 128, 1)">1000</span> <span style="color: rgba(128, 0, 128, 1)">1110</span></pre>
</div>
<p>左移后，第二到第七位表示器件地址，就能空出第一位用来放读写标志了。如果要写数据，就向从机发 1000 1110；要读数据，就向从机发 1000 1111。</p>
<p>注意，我们在调用库的时候，是不需要左移的，比如我们.NET中用的 System.Device.Gpio 库，内部会自动进行左移。</p>
<p>&nbsp;</p>
<p>好了，基础知识就介绍到这儿，相信你对 IIC 协议已经有大概的了解，下面咱们来看看 System.Device.Gpio 给我们准备了哪些类。</p>
<p><span style="color: rgba(0, 0, 128, 1)">A、命名空间：<em>System.Device.I2c</em></span></p>
<p><span style="color: rgba(0, 0, 128, 1)">B、I2cConnectionSettings 类，用来配置 IIC 通信的必要参数。其实就两个：第一个是总线ID，一般系统默认的是 1。第二个参数就是从机的地址（不需要左移）。</span></p>
<p><span style="color: rgba(0, 0, 128, 1)">C、<span class="hljs-title">I2cDevice，核心类，用于读写数据。这是个抽象类，内部根据不同的系统有各自的实现版本，但我们在调用时不用关心是哪个版本。</span></span></p>
<p><span style="color: rgba(0, 0, 128, 1)"><span class="hljs-title">D、</span>I2cBus，这个一般可以不用，如果硬件上有多个总线，可以使用这个类指定使用哪个总线。其实树莓派有两路 i2c 总线的，我们平时用的是 i2c-1，还有一个 i2c-0 是隐藏的，留给摄像头用的，可以参考官方文档。</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>        i2c_arm                 Set to <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">on</span><span style="color: rgba(128, 0, 0, 1)">"</span> to enable the ARM<span style="color: rgba(128, 0, 0, 1)">'</span><span style="color: rgba(128, 0, 0, 1)">s i2c interface</span>
                                (<span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">off</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        i2c_vc                  Set to </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">on</span><span style="color: rgba(128, 0, 0, 1)">"</span> to enable the i2c <span style="color: rgba(0, 0, 255, 1)">interface</span><span style="color: rgba(0, 0, 0, 1)">
                                usually reserved </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> the VideoCore processor
                                (</span><span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">off</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        i2c                     An alias </span><span style="color: rgba(0, 0, 255, 1)">for</span> i2c_arm</pre>
</div>
<p>&nbsp;</p>
<p>“i2c”和“i2c-arm”是同一个东东，只是名字不同罢了，所以，一块板子上就有 “i2c-arm”和“i2c-vc” 两路总线，“i2c-vc”分配给摄像头以及视频相关的接口使用。当然，你也可以拿“i2c-vc”作为常规总线用的，要把视频相关的接口禁用。如果两路都拿来用了，那么树莓派上就有两个总线ID，一个是 0，一个是 1。</p>
<p>另外，也可以使用软件模拟 i2c，这样你就可以弄出几个总线出来了——i2c-2、i2c-3、i2c-150 …… 配置如下：</p>
<div class="cnblogs_code">
<pre>Name:   i2c-<span style="color: rgba(0, 0, 0, 1)">gpio
Info:   Adds support </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> software i2c controller on gpio pins
Load:   dtoverlay</span>=i2c-gpio,&lt;param&gt;=&lt;val&gt;<span style="color: rgba(0, 0, 0, 1)">
Params: i2c_gpio_sda            GPIO used </span><span style="color: rgba(0, 0, 255, 1)">for</span> I2C data (<span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">23</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        i2c_gpio_scl            GPIO used </span><span style="color: rgba(0, 0, 255, 1)">for</span> I2C clock (<span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">24</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">)

        i2c_gpio_delay_us       Clock delay </span><span style="color: rgba(0, 0, 255, 1)">in</span><span style="color: rgba(0, 0, 0, 1)"> microseconds
                                (</span><span style="color: rgba(0, 0, 255, 1)">default</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">2</span><span style="color: rgba(128, 0, 0, 1)">"</span> = ~<span style="color: rgba(0, 0, 0, 1)">100kHz)

        bus                     Set to a unique, non</span>-zero value <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> wanting
                                multiple i2c</span>-gpio busses. If <span style="color: rgba(0, 0, 255, 1)">set</span><span style="color: rgba(0, 0, 0, 1)">, will be used
                                </span><span style="color: rgba(0, 0, 255, 1)">as</span> the preferred bus number (/dev/i2c-&lt;n&gt;<span style="color: rgba(0, 0, 0, 1)">). If
                                not </span><span style="color: rgba(0, 0, 255, 1)">set</span>, the <span style="color: rgba(0, 0, 255, 1)">default</span> value <span style="color: rgba(0, 0, 255, 1)">is</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">, but the bus
                                number will be dynamically assigned </span>-<span style="color: rgba(0, 0, 0, 1)"> probably
                                </span><span style="color: rgba(128, 0, 128, 1)">3</span>.</pre>
</div>
<p>这个只是提一下，必要时可以用上，软件模拟的接口通信，性能和效率会相对差一点的。</p>
<p>&nbsp;</p>
<p>树莓派默认是不打开 i2c 接口的，所以要在配置中将其打开。</p>
<div class="cnblogs_code">
<pre>sudo raspi-config</pre>
</div>
<p>找到接口选项。</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210130190420013-52870323.png" width="600" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;选择 P5 I2C 条目。</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210130190543924-443848956.png" width="600" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;然后选择“YES”。</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210130190734346-1163704671.png" width="500" loading="lazy"></p>
<p>&nbsp;</p>
<p>或者简单粗暴，修改 /boot/config.txt，加上这一行：</p>
<div class="cnblogs_code">
<pre>dtparam=i2c_arm=on</pre>
</div>
<p>保存退出。</p>
<p>&nbsp;</p>
<p>这一次的 IIC 演示实例，老周不使用传感器。主要担心有同学会误解，因为很多电子模块/传感器都是通过读写寄存器的方式来控制的，于是有同学会以为 IIC 是操作寄存来传递信息的。其实不然，跟 TCP 协议一样，你可以用 IIC 传递任何字节，只要能用二进制表示的就没问题了。</p>
<p>本例老周用一块 Arduino （读音：阿嘟伊诺，重音在后面，“伊诺”要读出来，别读什么“阿丢诺”）开发板做为 IIC 从机，型号为&nbsp; Uno R3（读音：乌诺，意大利语“第一”的意思，表明这是 Arduino 的首套板子）。然后用树莓派作为主机，来控制 Arduino。</p>
<p>Arduino 上使用 Wire 库进行 IIC 通信。首先要包含 Wire.h 头文件。</p>
<div class="cnblogs_code">
<pre>#include &lt;Wire.h&gt;</pre>
</div>
<p>在这个头文件中，注意有这么一行。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">extern</span> TwoWire Wire;</pre>
</div>
<p>其实头文件中声明的封装类名为 TowWire，然后在头文件中用这个类声明了一个变量 Wire，加上 extern 关键字使得其他代码能访问到它，只要 include 这个头文件就OK了。Wire 变量的赋值代码在 Wire.cpp 文件中（提前给你实例化一个对象了）。</p>
<div class="cnblogs_code">
<pre>TwoWire Wire = TwoWire();</pre>
</div>
<p>这样布局代码的好处在于：包含 Wire.h 文件后，你马上就能用了，直接就可以通过 Wire 变量调用 TwoWire 的公共成员了。</p>
<p>Arduino 代码一般有两个特定的函数：</p>
<p>setup：初始化一些设置，比如某某引脚设定为输出模式。此函数会在程序在烧进板子上时执行一次，然后就不会执行，进入 loop 函数死循环。但是，如果你按了复位按钮，或者断电了重新上电，就会执行 setup 函数。</p>
<p>loop：这个函数被放在一个 die 循环里，它会无限期地被调用，只要程序被烧进开发板上就会永远地循环。</p>
<p>有同学会问：C/C++不是有入口点吗，main 函数滚哪里去了？main 函数在 main.cpp 文件中，编译时由 Arduino 编译器自动链接。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)">)
{
    ……
    
    <em><strong>setup();
    
    </strong></em></span><em><strong><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (;;) {
        loop();
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (serialEventRun) serialEventRun();
    }
        
    </span></strong></em><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
}</span></pre>
</div>
<p>从入口点函数的逻辑中也看到，setup 函数只调用了一次，然后 loop 函数死循环。</p>
<p>好了，题外话结束，下面咱们回到 Arduino 的项目中，在setup函数中调用 Wire.begin 方法，开始 IIC 通信。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> setup()
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 该从机的地址是 0x15</span>
    Wire.begin(<span style="color: rgba(128, 0, 128, 1)">0x15</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 注册函数，当收到主机数据时调用</span>
<span style="color: rgba(0, 0, 0, 1)">    Wire.onReceive(onRecData);
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 注册函数，当主机请求数据时调用</span>
<span style="color: rgba(0, 0, 0, 1)">    Wire.onRequest(onRequestData);
}</span></pre>
</div>
<p>如果 Arduino 作为 IIC 主机，调用 begin 方法时不需要指定地址；此例中 Arduino 充当从机，所以要指定从机地址 0x15（你可以改为其他地址，一般用7位）。树莓派上的应用会使用地址 0x15 来找到这块 Uno 板子。</p>
<p>注意这两行：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 0, 1)">    Wire.onReceive(onRecData);
    Wire.onRequest(onRequestData);</span></pre>
</div>
<p>这两个方法的参数都是指向一个函数的指针，传递时直接写函数名即可。onRecieve 方法注册一个函数，当收到主机发来的数据时调用这个函数；onRepuest 方法注册一个函数，当主机希望从机发送数据时调用这个函数。</p>
<p>onRecData 和 onRequestData 函数定义如下：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span> onRecData(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> count)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (Wire.available())
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读一个字节</span>
        readData =<span style="color: rgba(0, 0, 0, 1)"> Wire.read();
    }
}

</span><span style="color: rgba(0, 0, 255, 1)">void</span> onRequestData(<span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)">)
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 向主机发数据</span>
<span style="color: rgba(0, 0, 0, 1)">    Wire.write(sendData);
}</span></pre>
</div>
<p>在这个示例中，主机只向从机发一个字节，所以参数 count 可以忽略，直接调用 Wire.read 读一个字节，并保存在变量 readData 中；发送数据时调用 Wire.write 方法将 sendData 中的内容发送给主机。在loop循环中，根据readData的值生成sendData的内容——根据主机发的命令生成回复消息。</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> loop()
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 根据主机传来的数据设置要发给主机的数据</span>
    <span style="color: rgba(0, 0, 255, 1)">switch</span><span style="color: rgba(0, 0, 0, 1)"> (readData)
    {
    </span><span style="color: rgba(0, 0, 255, 1)">case</span> <span style="color: rgba(128, 0, 128, 1)">1</span><span style="color: rgba(0, 0, 0, 1)">:
        strcpy(sendData, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">SB</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">case</span> <span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">:
        strcpy(sendData, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">NB</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">case</span> <span style="color: rgba(128, 0, 128, 1)">3</span><span style="color: rgba(0, 0, 0, 1)">:
        strcpy(sendData, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">XB</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    </span><span style="color: rgba(0, 0, 255, 1)">default</span><span style="color: rgba(0, 0, 0, 1)">:
        strcpy(sendData, </span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">SB</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
    }
}</span></pre>
</div>
<p>完整代码结构如下；</p>
<div class="cnblogs_code">
<pre>#include &lt;Wire.h&gt;

<span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 预声明函数</span>
<span style="color: rgba(0, 0, 255, 1)">void</span> onRecData(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)">);
</span><span style="color: rgba(0, 0, 255, 1)">void</span> onRequestData(<span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)">);

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 从主机读到的数据</span>
uint8_t readData = <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;

</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 要发给主机的数据
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 两个字符 + \0，所以是3字节
</span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 但这里不需要 \0</span>
<span style="color: rgba(0, 0, 255, 1)">char</span> sendData[<span style="color: rgba(128, 0, 128, 1)">2</span>] = <span style="color: rgba(128, 0, 0, 1)">{ }</span><span style="color: rgba(0, 0, 0, 1)">;

</span><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> setup()
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 该从机的地址是 0x15</span>
    Wire.begin(<span style="color: rgba(128, 0, 128, 1)">0x15</span><span style="color: rgba(0, 0, 0, 1)">);
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 注册函数，当收到主机数据时调用</span>
<span style="color: rgba(0, 0, 0, 1)">    Wire.onReceive(onRecData);
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 注册函数，当主机请求数据时调用</span>
<span style="color: rgba(0, 0, 0, 1)">    Wire.onRequest(onRequestData);
}

</span><span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> loop()
{
    ……
}

</span><span style="color: rgba(0, 0, 255, 1)">void</span> onRecData(<span style="color: rgba(0, 0, 255, 1)">int</span><span style="color: rgba(0, 0, 0, 1)"> count)
{
    </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (Wire.available())
    {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 读一个字节</span>
        readData =<span style="color: rgba(0, 0, 0, 1)"> Wire.read();
    }
}

</span><span style="color: rgba(0, 0, 255, 1)">void</span> onRequestData(<span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)">)
{
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 向主机发数据</span>
<span style="color: rgba(0, 0, 0, 1)">    Wire.write(sendData);
}</span></pre>
</div>
<p>&nbsp;</p>
<p>接下来编写树莓派上的应用。</p>
<div class="cnblogs_code">
<pre>dotnet <span style="color: rgba(0, 0, 255, 1)">new</span> console -n Myapp -o .</pre>
</div>
<p>上面命令创建新的控制台项目，名为Myapp，存放在当前目录下。</p>
<p>添加 System.Device.Gpio 包的引用。</p>
<div class="cnblogs_code">
<pre>dotnet add package System.Device.Gpio</pre>
</div>
<p>前文提到过，默认启用的 IIC 总线是 i2c-1，所以实例化&nbsp;I2cConnectionSettings 时，Bus ID 是1，从机地址是 0x15。</p>
<div class="cnblogs_code">
<pre>    I2cConnectionSettings settings = <span style="color: rgba(0, 0, 255, 1)">new</span>(<span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">0x15</span>);</pre>
</div>
<p>随后获取&nbsp;I2cDevice 对象。</p>
<div class="cnblogs_code">
<pre>    I2cDevice device = I2cDevice.Create(settings);</pre>
</div>
<p>本例的逻辑为：由用户从键盘输入数字（1、2、3），然后把这个数字发给从机（Arduino 板子），然后读取从机回复的数据。</p>
<div class="cnblogs_code">
<pre>            <span style="color: rgba(0, 0, 255, 1)">byte</span> input = <span style="color: rgba(128, 0, 128, 1)">0</span>; <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">读取键盘输入</span>
            Console.WriteLine(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">现在开始，输入 end 可退出</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
            </span><span style="color: rgba(0, 0, 255, 1)">while</span> (<span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">)
            {
                Console.Write(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">请输入：</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">);
                </span><span style="color: rgba(0, 0, 255, 1)">string</span> sl =<span style="color: rgba(0, 0, 0, 1)"> Console.ReadLine();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (sl.Equals(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">end</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, StringComparison.InvariantCultureIgnoreCase))
                {
                    </span><span style="color: rgba(0, 0, 255, 1)">break</span><span style="color: rgba(0, 0, 0, 1)">;
                }
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 将输入内容转为byte</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 255, 1)">byte</span>.TryParse(sl, <span style="color: rgba(0, 0, 255, 1)">out</span><span style="color: rgba(0, 0, 0, 1)"> input))
                {
                    input </span>= <span style="color: rgba(128, 0, 128, 1)">0</span><span style="color: rgba(0, 0, 0, 1)">;
                }
                </span><span style="color: rgba(0, 128, 0, 1)">/*</span><span style="color: rgba(0, 128, 0, 1)">
                //发送数据
                device.WriteByte(input);
                Thread.Sleep(3);
                // 接收从机发来的数据
                Span&lt;byte&gt; buffer = stackalloc byte[3];
                device.Read(buffer);
                </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
                <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 可以一步到位，写完就读</span>
                <span style="color: rgba(0, 0, 255, 1)">byte</span>[] sendBuf = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span><span style="color: rgba(0, 0, 0, 1)">[] { input };
                </span><span style="color: rgba(0, 0, 255, 1)">byte</span>[] recvBuf = <span style="color: rgba(0, 0, 255, 1)">new</span> <span style="color: rgba(0, 0, 255, 1)">byte</span>[<span style="color: rgba(128, 0, 128, 1)">2</span><span style="color: rgba(0, 0, 0, 1)">];
                device.WriteRead(sendBuf, recvBuf);
                </span><span style="color: rgba(0, 0, 255, 1)">string</span> sr =<span style="color: rgba(0, 0, 0, 1)"> Encoding.Default.GetString(recvBuf);
                Console.WriteLine(</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">接收到的数据：{0}</span><span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(0, 0, 0, 1)">, sr);
            }
            device.Dispose();</span></pre>
</div>
<p>可以调用 WriteXXX 类似方法写入要发送的数据，调用 ReadXXX 类似的方法读入接收到的数据。也可以用 WriteRead 方法，写入数据后接收数据，一步完成。</p>
<p>&nbsp;</p>
<p>接线方法：树莓派默认的 IIC 引脚为 GPIO 2和3，即板子上的3、5脚；Arduino 的 SDA 引脚为 A4，SCL引脚为 A5（A4和A5为模拟量读入口，可重用为 IIC 接口），其实 Arduino 还有一路 IIC 接口，位于数字引脚 D13 、GND、AREF后面，就是这里：</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210131170139546-1332920483.jpg" width="350" loading="lazy"></p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210131170703709-316694155.png" width="450" loading="lazy"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;所以，接线图如下：</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210131170849871-303040747.png" width="750" loading="lazy"></p>
<p>也就是，树莓派的 GPIO 2 接 Arduino 的 A4，树莓派的 GPIO 3 接 Arduino 的 A5。另外，还要把两个板子的 GND 连起来（共地），虽然不共地也能通信，但可能存在被干扰的情况，共地后使用低电平的“0V”有了统一的参考标准，这样传递信号准确更高。</p>
<p>如果 Arduino 开发板没有独立供电，可以把树莓派的 5V 与 Arduino 的 VIN 连接起来，用树莓派给 Arduino 供电（VIN的输入电压不能高于 12V，因为这个引脚没有保护措施，过压会炸板子）。</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210131172753825-647378039.png" width="750" loading="lazy"></p>
<p>&nbsp;</p>
<p>编译 .NET 应用并上传到树莓派，然后运行，输入不同数字，Arduino 会回复对应的消息。</p>
<p><img src="https://img2020.cnblogs.com/blog/367389/202101/367389-20210131173057862-2109840515.png" width="300" loading="lazy"></p>
<p>&nbsp;</p>
<p>好了，完工，示例代码请点击<a href="https://files.cnblogs.com/files/tcjiaan/iicSample.zip" target="_blank">这里</a>下载。</p>
<p>有人会问，树莓派有没有山寨版？有，比如橙子派什么的，某宝上还有荔枝派。这些板子大多数不贵，但是不太敢买，还是买原装的好一些。 Arduino 是开源板子，版本也很多（也有山寨的），像 DFRobot 好像也可以，还有很多十几块的没名字的，所以也叫不出什么版本，只能说山寨了。不过说实话，还是原装的运行稳定，尽管贵一些。老周当初也是买了几块那种十几块的，上传程序经常出错，装驱动也头疼。原版的稳定，起码用到现在也出过错，也不用找驱动，Windows 能识别。</p>
<p>所以说嘛，一分价钱一分货，后来老周干脆放点血买原装版本的。</p>
<p>&nbsp;</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-01-31 17:48</span>&nbsp;
<a href="https://www.cnblogs.com/tcjiaan/">东邪独孤</a>&nbsp;
阅读(<span id="post_view_count">554</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14348436" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14348436);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 113198, cb_blogApp = 'tcjiaan', cb_blogUserGuid = '9874e16f-6837-e111-b988-842b2b196315';
    var cb_entryId = 14348436, cb_entryCreatedDate = '2021-01-31 17:48', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2021 东邪独孤
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAju0U856cJvxyY0oRTsfAGtT59wy9kPlfAmo2cOw8gEkhHwS3rYbDfSAaeyDDiwl7f8rzgtafvfEElvaAf9A4e9YuTg6EpI-y6BQvr90vBFJsM7HDL5IBpP7G6wbOJu5lAA" />
</body>
</html>
